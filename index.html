<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>AR Clickable Cubes</title>
    <!-- Подключаем Three.js -->
    <script src="https://cdn.jsdelivr.net/npm/three@0.130.1/build/three.min.js"></script>
    <!-- Подключаем GLTFLoader -->
    <script src="https://cdn.jsdelivr.net/npm/three@0.130.1/examples/js/loaders/GLTFLoader.js"></script>
  </head>
  <body style="margin: 0; overflow: hidden;">
    <!-- Подключаем ARButton как модуль -->
    <script type="module">
      import { ARButton } from 'https://cdn.jsdelivr.net/npm/three@0.130.1/examples/jsm/webxr/ARButton.js';

      let camera, scene, renderer;
      let model1, model2;
      let raycaster = new THREE.Raycaster();
      let isModel1Scaled = false;
      let isModel2Scaled = false;
      let scalingSpeed = 0.1;  // Скорость анимации
      let standartModelScale = 0.03;
      let smallModelScale = 0.015;
      let bigModelScale = 0.06;

      init();
      animate();

      function init() {
        // Создание сцены
        scene = new THREE.Scene();

        // Настройка камеры
        // Устанавливаем позицию камеры сверху
        camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(0, 2, 2); // Поднимаем камеру на высоту 2 по оси Y и устанавливаем её немного назад
        camera.lookAt(0, 0, 0); // Направляем камеру на центр сцены
        scene.add(camera);

        // Создание рендерера с поддержкой WebXR
        renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.xr.enabled = true;
        document.body.appendChild(renderer.domElement);

        // Добавляем AR-кнопку
        const arButton = ARButton.createButton(renderer);
        document.body.appendChild(arButton);
        
        // Добавляем свет в сцену
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.8);
        scene.add(ambientLight);

        const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
        directionalLight.position.set(1, 1, 1).normalize();
        scene.add(directionalLight);

         // Используем GLTFLoader для загрузки моделей
         const loader = new THREE.GLTFLoader();

         // Загрузка первой модели
        loader.load('models/building1.glb', function (gltf) {
          model1 = gltf.scene;
          model1.position.set(-0.1, 0, -1);  // Позиционируем первую модель
          model1.scale.set(standartModelScale, standartModelScale, standartModelScale);  // Устанавливаем начальный размер
          scene.add(model1);
        });

        // Загрузка второй модели
        loader.load('models/building2.glb', function (gltf) {
          model2 = gltf.scene;
          model2.position.set(0.1, 0, -1);  // Позиционируем вторую модель
          model2.scale.set(standartModelScale, standartModelScale, standartModelScale);  // Устанавливаем начальный размер
          scene.add(model2);
        });

        // Контроллер для обработки кликов в AR
        const controller = renderer.xr.getController(0);
        controller.addEventListener('selectstart', onSelectStart);
        scene.add(controller);

        // Изменение размеров окна
        window.addEventListener('resize', onWindowResize, false);
      }

      function onWindowResize() {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
      }

      function onSelectStart(event) {
        // Определение пересечения луча с объектами
        raycaster.setFromCamera({ x: 0, y: 0 }, camera);
        const intersects = raycaster.intersectObjects([model1, model2], true);

        if (intersects.length > 0) {
          const clickedModel = intersects[0].object;

          if (clickedModel.parent === model1) {
            if (!isModel1Scaled) {
              animateScaling(model1, bigModelScale);  // Увеличиваем модель 1
              animateScalingAndOpacity(model2, smallModelScale, 0.3);  // Уменьшаем и делаем модель 2 полупрозрачной
              isModel1Scaled = true;
            } else {
              resetModels();  // Возвращаем модели к исходным размерам
            }
          }

          if (clickedModel.parent === model2) {
            if (!isModel2Scaled) {
              animateScaling(model2, bigModelScale);  // Увеличиваем модель 2
              animateScalingAndOpacity(model1, smallModelScale, 0.3);  // Уменьшаем и делаем модель 1 полупрозрачной
              isModel2Scaled = true;
            } else {
              resetModels();  // Возвращаем модели к исходным размерам
            }
          }
        } else {
          resetModels();  // Возвращаем модели к исходным размерам при клике в пустую область
        }
      }

      function resetModels() {
        animateScaling(model1, standartModelScale);  // Возвращаем модель 1 к исходному размеру
        animateScaling(model2, standartModelScale);  // Возвращаем модель 2 к исходному размеру
        animateScalingAndOpacity(model1, standartModelScale, 1);  // Возвращаем модель 1 к нормальному размеру и прозрачности
        animateScalingAndOpacity(model2, standartModelScale, 1);  // Возвращаем модель 2 к нормальному размеру и прозрачности
        isModel1Scaled = false;
        isModel2Scaled = false;
      }

      function animateScaling(model, targetScale, onComplete = null) {
        const startScale = model.scale.x;
        const scaleDiff = targetScale - startScale;
        let progress = 0;

        function animate() {
          progress += scalingSpeed;
          const newScale = startScale + scaleDiff * progress;

          model.scale.set(newScale, newScale, newScale);

          if (progress < 1) {
            requestAnimationFrame(animate);
          } else if (onComplete) {
            onComplete();  // Выполняем коллбек после завершения анимации
          }
        }

        requestAnimationFrame(animate);
      }

      function animateScalingAndOpacity(model, targetScale, targetOpacity, onComplete = null) {
        const startScale = model.scale.x;
        const startOpacity = model.children[0].material.opacity;  // Предполагается, что модель имеет материал с прозрачностью
        const scaleDiff = targetScale - startScale;
        const opacityDiff = targetOpacity - startOpacity;
        let progress = 0;

        function animate() {
          progress += scalingSpeed;
          const newScale = startScale + scaleDiff * progress;
          const newOpacity = startOpacity + opacityDiff * progress;

          model.scale.set(newScale, newScale, newScale);

          // Устанавливаем прозрачность для всех дочерних материалов
          model.traverse((child) => {
            if (child.isMesh && child.material) {
              child.material.transparent = true;
              child.material.opacity = newOpacity;
            }
          });

          if (progress < 1) {
            requestAnimationFrame(animate);
          } else if (onComplete) {
            onComplete();  // Выполняем коллбек после завершения анимации
          }
        }

        requestAnimationFrame(animate);
      }

      function animate() {
        renderer.setAnimationLoop(render);
      }

      function render() {
        renderer.render(scene, camera);
      }
    </script>
  </body>
</html>
