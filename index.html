<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>AR Clickable Cubes</title>
    <!-- Подключаем Three.js -->
    <script src="https://cdn.jsdelivr.net/npm/three@0.130.1/build/three.min.js"></script>
    <!-- Подключаем GLTFLoader -->
    <script src="https://cdn.jsdelivr.net/npm/three@0.130.1/examples/js/loaders/GLTFLoader.js"></script>
  </head>
  <body style="margin: 0; overflow: hidden;">
    <!-- Подключаем ARButton как модуль -->
    <script type="module">
      import { ARButton } from 'https://cdn.jsdelivr.net/npm/three@0.130.1/examples/jsm/webxr/ARButton.js';

      let camera, scene, renderer;
      let model1, model2;
      let raycaster = new THREE.Raycaster();
      let mouse = new THREE.Vector2();

      let isModel1Scaled = false;
      let isModel2Scaled = false;
      let scalingSpeed = 0.1;  // Скорость анимации
      let standartModelScale = 0.5;
      let smallModelScale = 0.25;
      let bigModelScale = 0.75;

      init();
      animate();

      function init() {
        // Создание сцены
        scene = new THREE.Scene();

        // Настройка камеры
        // Устанавливаем позицию камеры сверху
        camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(0, 1, 1); // Поднимаем камеру на высоту 2 по оси Y и устанавливаем её немного назад
        camera.lookAt(0, 0, 0); // Направляем камеру на центр сцены
        scene.add(camera);

        // Создание рендерера с поддержкой WebXR
        renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.xr.enabled = true;
        document.body.appendChild(renderer.domElement);

        // Добавляем AR-кнопку
        const arButton = ARButton.createButton(renderer);
        document.body.appendChild(arButton);
        
        // Добавляем свет в сцену
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.8);
        scene.add(ambientLight);

        const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
        directionalLight.position.set(1, 1, 1).normalize();
        scene.add(directionalLight);

         // Используем GLTFLoader для загрузки моделей
         const loader = new THREE.GLTFLoader();

         // Добавление первого куба
        const geometry = new THREE.BoxGeometry(0.5, 0.5, 0.5);
        const material1 = new THREE.MeshBasicMaterial({ color: 0xff0000, transparent: true, opacity: 1 });
        model1 = new THREE.Mesh(geometry, material1);
        model1.position.set(-0.5, 0, -1);  // Перемещаем кубы дальше друг от друга
        scene.add(model1);

        // Добавление второго куба
        const material2 = new THREE.MeshBasicMaterial({ color: 0x0000ff, transparent: true, opacity: 1 });
        model2 = new THREE.Mesh(geometry, material2);
        model2.position.set(0.5, 0, -1);
        scene.add(model2);

         // Загрузка первой модели
        // loader.load('models/building1.glb', function (gltf) {
        //   model1 = gltf.scene;
        //   model1.position.set(-0.1, 0, -1);  // Позиционируем первую модель
        //   model1.scale.set(standartModelScale, standartModelScale, standartModelScale);  // Устанавливаем начальный размер
        //   scene.add(model1);
        // });

        // // Загрузка второй модели
        // loader.load('models/building2.glb', function (gltf) {
        //   model2 = gltf.scene;
        //   model2.position.set(0.1, 0, -1);  // Позиционируем вторую модель
        //   model2.scale.set(standartModelScale, standartModelScale, standartModelScale);  // Устанавливаем начальный размер
        //   scene.add(model2);
        // });

        // Изменение размеров окна
        window.addEventListener('resize', onWindowResize, false);

        // Добавляем обработчик событий для тапа (нажатия)
        window.addEventListener('touchstart', onTap, false); // Для мобильных устройств
      }

          // Функция для обработки кликов/тапов
        function onTap(event) {
        if (event.type === 'touchstart') {
          // Для касания: нормализуем координаты тапа (от -1 до 1)
          mouse.x = (event.touches[0].clientX / window.innerWidth) * 2 - 1;
          mouse.y = -(event.touches[0].clientY / window.innerHeight) * 2 + 1;
        }
          // Устанавливаем луч от камеры в сторону координат клика/тапа
          raycaster.setFromCamera(mouse, camera);

        // Находим объекты, которые пересекает луч
        const intersects = raycaster.intersectObjects([model1, model2], true);

        // Если пересекает объект, выполняем действия
        if (intersects.length > 0) {
            const clickedModel = intersects[0].object;

        // Логика клика по объекту — увеличиваем его, а другие модели уменьшаем и делаем полупрозрачными
        if (!isModelScaled) {
          clickedModel.scale.set(bigModelScale, bigModelScale, bigModelScale); // Увеличиваем выбранную модель
          clickedModel.material.opacity = 1.0; // Ставим полную видимость для этой модели

          // Для остальных объектов — уменьшаем и делаем полупрозрачными
          [model1, model2].forEach((model) => {
            if (model !== clickedModel) {
              model.scale.set(smallModelScale, smallModelScale, smallModelScale); // Уменьшаем модель
              model.material.transparent = true; // Включаем прозрачность
              model.material.opacity = 0.5; // Делаем модель полупрозрачной
            }
          });

          isModelScaled = true;
        } else {
          // Возвращаем все модели в исходное состояние
          resetModels();
        }
      } else {
        // Если клик вне моделей, возвращаем все модели в исходное состояние
        resetModels();
      }
      }

      function onWindowResize() {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
      }

      function resetModels() {    
        animateScalingAndOpacity(model1, standartModelScale, 1);  // Возвращаем модель 1 к нормальному размеру и прозрачности
        animateScalingAndOpacity(model2, standartModelScale, 1);  // Возвращаем модель 2 к нормальному размеру и прозрачности
        isModel1Scaled = false;
        isModel2Scaled = false;
      }

      function animateScaling(model, targetScale, onComplete = null) {
        const startScale = model.scale.x;
        const scaleDiff = targetScale - startScale;
        let progress = 0;

        function animate() {
          progress += scalingSpeed;
          const newScale = startScale + scaleDiff * progress;

          model.scale.set(newScale, newScale, newScale);

          if (progress < 1) {
            requestAnimationFrame(animate);
          } else if (onComplete) {
            onComplete();  // Выполняем коллбек после завершения анимации
          }
        }

        requestAnimationFrame(animate);
      }

      function animateScalingAndOpacity(model, targetScale, targetOpacity, onComplete = null) {
        const startScale = model.scale.x;
        const startOpacity = model.children[0].material.opacity;  // Предполагается, что модель имеет материал с прозрачностью
        const scaleDiff = targetScale - startScale;
        const opacityDiff = targetOpacity - startOpacity;
        let progress = 0;

        function animate() {
          progress += scalingSpeed;
          const newScale = startScale + scaleDiff * progress;
          const newOpacity = startOpacity + opacityDiff * progress;

          model.scale.set(newScale, newScale, newScale);

          // Устанавливаем прозрачность для всех дочерних материалов
          model.traverse((child) => {
            if (child.isMesh && child.material) {
              child.material.transparent = true;
              child.material.opacity = newOpacity;
            }
          });

          if (progress < 1) {
            requestAnimationFrame(animate);
          } else if (onComplete) {
            onComplete();  // Выполняем коллбек после завершения анимации
          }
        }

        requestAnimationFrame(animate);
      }

      function animate() {
        renderer.setAnimationLoop(render);
      }

      function render() {
        renderer.render(scene, camera);
      }
    </script>
  </body>
</html>
