<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>AR Clickable Cubes</title>
  <!-- Подключаем Three.js -->
  <script src="https://cdn.jsdelivr.net/npm/three@0.130.1/build/three.min.js"></script>
  <!-- Подключаем GLTFLoader -->
  <script src="https://cdn.jsdelivr.net/npm/three@0.130.1/examples/js/loaders/GLTFLoader.js"></script>
</head>

<body style="margin: 0; overflow: hidden;">
  <!-- Подключаем ARButton как модуль -->
  <script type="module">
    import { ARButton } from 'https://cdn.jsdelivr.net/npm/three@0.130.1/examples/jsm/webxr/ARButton.js';

    let camera, scene, renderer;
    let model1, model2, model3;
    let raycaster = new THREE.Raycaster();
    let pointer = new THREE.Vector2();

    let isModel1Scaled = false;
    let isModel2Scaled = false;
    let isModelScaled = false;
    let scalingSpeed = 0.0005;  // Скорость анимации
    let standartModelScale = 0.03;
    let smallModelScale = 0.015;
    let bigModelScale = 0.05;
    const objects = [];

    init();
    render();
    animate();

    function init() {
      // Создание сцены
      scene = new THREE.Scene();

      // Настройка камеры
      // Устанавливаем позицию камеры сверху
      camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 0.1, 1000);
      camera.position.set(0, 1, 1); // Поднимаем камеру на высоту 2 по оси Y и устанавливаем её немного назад
      camera.lookAt(0, 0, 1); // Направляем камеру на центр сцены
      scene.add(camera);

      // Создание рендерера с поддержкой WebXR
      renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.xr.enabled = true;
      document.body.appendChild(renderer.domElement);

      // Добавляем AR-кнопку
      const arButton = ARButton.createButton(renderer);
      document.body.appendChild(arButton);

      // Добавляем свет в сцену
      const ambientLight = new THREE.AmbientLight(0xffffff, 0.8);
      scene.add(ambientLight);

      const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
      directionalLight.position.set(1, 1, 1).normalize();
      scene.add(directionalLight);

      // Используем GLTFLoader для загрузки моделей
      const loader = new THREE.GLTFLoader();

      // Добавление первого куба
      const geometry = new THREE.BoxGeometry(1, 1, 1);

      // const material1 = new THREE.MeshBasicMaterial({ color: 0xff0000, transparent: true, opacity: 1 });
      // model1 = new THREE.Mesh(geometry, material1);
      // model1.scale.set(standartModelScale, standartModelScale, standartModelScale);
      // model1.position.set(-0.5, 0, -0.5);  // Перемещаем кубы дальше друг от друга


      // // Добавление второго куба
      // const material2 = new THREE.MeshBasicMaterial({ color: 0x0000ff, transparent: true, opacity: 1 });
      // model2 = new THREE.Mesh(geometry, material2);
      // model2.scale.set(standartModelScale, standartModelScale, standartModelScale);
      // model2.position.set(0.5, 0, -0.5);


      // // Добавление второго куба
      // const material3 = new THREE.MeshBasicMaterial({ color: 0x00ff00, transparent: true, opacity: 1 });
      // model3 = new THREE.Mesh(geometry, material2);
      // model3.scale.set(standartModelScale, standartModelScale, standartModelScale);
      // model3.position.set(0, 0, 0.5);


      //Загрузка первой модели
      loader.load('models/building1.glb', function (gltf) {
        model1 = gltf.scene;
        model1.position.set(-0.1, 0, -1);  // Позиционируем первую модель
        model1.scale.set(standartModelScale, standartModelScale, standartModelScale);  // Устанавливаем начальный размер
        scene.add(model1);
        objects.push(model1);
      });

      // Загрузка второй модели
      loader.load('models/building2.glb', function (gltf) {
        model2 = gltf.scene;
        model2.position.set(0.1, 0, -1);  // Позиционируем вторую модель
        model2.scale.set(standartModelScale, standartModelScale, standartModelScale);  // Устанавливаем начальный размер
        scene.add(model2);
        objects.push(model2);
      });
       // Загрузка второй модели
       loader.load('models/building1.glb', function (gltf) {
        model3 = gltf.scene;
        model3.position.set(0, 0, -0.5);  // Позиционируем вторую модель
        model3.scale.set(standartModelScale, standartModelScale, standartModelScale);  // Устанавливаем начальный размер
        scene.add(model3);
        objects.push(model3);
      });

      console.log(objects);
     
     
     
      // Изменение размеров окна
      window.addEventListener('resize', onWindowResize, false);

      // Добавляем обработчик событий для тапа (нажатия)
      document.addEventListener('pointerdown', onPointerDown, false);
    }

    function onPointerDown(event) {
      pointer.set((event.clientX / window.innerWidth) * 2 - 1, - (event.clientY / window.innerHeight) * 2 + 1);
      raycaster.setFromCamera(pointer, camera);
      const intersects = raycaster.intersectObjects(objects, false);

      if (intersects.length > 0) {
        const clickedModel = intersects[0].object;
        if (!isModelScaled) {
          animateScaling(clickedModel, bigModelScale);
          objects.forEach((model) => {
            if (model !== clickedModel) {             
              animateScaling(model, smallModelScale);
              // animateScalingAndOpacity(model, smallModelScale, 0.3);
            }
          });
          isModelScaled = true;
        }
        else {
          resetModels();
        }
      }
      else {
        resetModels();
      }
    }

  

    function resetModels() {
      objects.forEach((model) => {
        // animateScalingAndOpacity(model, smallModelScale, 0.3);
        animateScaling(model, standartModelScale);
        
      });
      isModelScaled = false;
    }

    function animateScaling(model, targetScale, onComplete = null) {
      model.scale.set(targetScale, targetScale, targetScale);
      // const startScale = model.scale.x;
      // const scaleDiff = targetScale - startScale;
      // let progress = 0;

      // function animate() {
      //   progress += scalingSpeed;
      //   const newScale = startScale + scaleDiff * progress;

      //   model.scale.set(newScale, newScale, newScale);
      //   console.log(model.scale);
      //   if (progress < 1) {
      //     requestAnimationFrame(animate);
      //   } else if (onComplete) {
      //     onComplete();  // Выполняем коллбек после завершения анимации
      //   }
      // }

      requestAnimationFrame(animate);
    }

    function animateScalingAndOpacity(model, targetScale, targetOpacity, onComplete = null) {
      const startScale = model.scale.x;
      const startOpacity = model.material.opacity;  // Предполагается, что модель имеет материал с прозрачностью
      const scaleDiff = targetScale - startScale;
      const opacityDiff = targetOpacity - startOpacity;
      let progress = 0;

      function animate() {
        progress += scalingSpeed;
        const newScale = startScale + scaleDiff * progress;
        const newOpacity = startOpacity + opacityDiff * progress;

        model.scale.set(newScale, newScale, newScale);

        // Устанавливаем прозрачность для всех дочерних материалов
        model.traverse((child) => {
          if (child.isMesh && child.material) {
            child.material.transparent = true;
            child.material.opacity = newOpacity;
          }
        });

        if (progress < 1) {
          requestAnimationFrame(animate);
        } else if (onComplete) {
          onComplete();  // Выполняем коллбек после завершения анимации
        }
      }

      requestAnimationFrame(animate);
    }

    function onWindowResize() {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    }

    function animate() {
      renderer.setAnimationLoop(render);
    }

    function render() {
      renderer.render(scene, camera);
    }
  </script>
</body>

</html>
